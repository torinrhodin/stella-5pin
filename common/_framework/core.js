// Generated by CoffeeScript 1.10.0
(function() {
  var AutoMenu, Collection, InlineScroller, Presentation, Slidescroller, Slideshow, View, d, lastSlide,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  d = document;

  window.presentationInit = d.createEvent('UIEvents');

  window.slideshowLoad = d.createEvent('UIEvents');

  window.slideshowUnload = d.createEvent('UIEvents');

  window.collectionLoad = d.createEvent('UIEvents');

  window.collectionUnload = d.createEvent('UIEvents');

  window.contentLoad = d.createEvent('UIEvents');

  window.contentUnload = d.createEvent('UIEvents');

  window.slideEnter = d.createEvent('UIEvents');

  window.slideExit = d.createEvent('UIEvents');

  window.sectionEnter = d.createEvent('UIEvents');

  window.sectionExit = d.createEvent('UIEvents');

  window.appError = d.createEvent('UIEvents');

  presentationInit.initEvent('presentationInit', false, false);

  slideshowLoad.initEvent('slideshowLoad', true, false);

  slideshowUnload.initEvent('slideshowUnload', true, false);

  collectionLoad.initEvent('collectionLoad', true, false);

  collectionUnload.initEvent('collectionUnload', true, false);

  contentLoad.initEvent('contentLoad', true, false);

  contentUnload.initEvent('contentUnload', true, false);

  slideEnter.initEvent('slideEnter', true, false);

  slideExit.initEvent('slideExit', true, false);

  sectionEnter.initEvent('sectionEnter', true, false);

  sectionExit.initEvent('sectionExit', true, false);

  appError.initEvent('appError', true, false);

  d = document;

  lastSlide = null;

  window.Presentation = Presentation = (function() {
    function Presentation(config) {
      var collection, i, j, len, len1, ref, ref1, slideshow;
      window.app = this;
      this.config = config || {};
      this.type = config.type || 'dynamic';
      this.isLinear = config.isLinear || false;
      this.orientation = config.orientation || 'landscape';
      this.dimensions = this.orientation === 'landscape' ? [1024, 768] : [768, 1024];
      this.version = '2.5.2';
      this.manageMemory = config.manageMemory || false;
      this.wrapSlides = config.wrapSlides || this.manageMemory;
      this.pathToSlides = this.config.pathToSlides || 'slides/';
      this.loaded = null;
      this.savedEvents = {};
      this.slideshows = {};
      this.collections = {};
      this.manager = {};
      this.currentSlide = "";
      this.setupByType();
      this.getElements();
      this.getAllSlides();
      ref = this.slideshowIds;
      for (i = 0, len = ref.length; i < len; i++) {
        slideshow = ref[i];
        this.register(slideshow, this.slides[slideshow]);
      }
      ref1 = this.collectionIds;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        collection = ref1[j];
        this.register(collection, this.sections[collection], 'collection');
      }
      d.addEventListener('slideEnter', (function(_this) {
        return function(e) {
          return _this.currentSlide = e.target.id;
        };
      })(this));
      d.dispatchEvent(presentationInit);
      return;
    }

    Presentation.prototype.setupByType = function() {
      var content, structure;
      if (this.type === 'dynamic') {
        this.slides = this.config.slideshows || {};
        this.sections = this.config.collections || {};
      } else if (this.type === 'json') {
        this.json = {};
        this.slides = {};
        this.sections = {};
        this.getData('presentation.json', (function(_this) {
          return function(data) {
            return _this.json = data;
          };
        })(this));
        for (structure in this.json.structures) {
          content = this.json.structures[structure].content;
          if (this.json.structures[structure].type === 'slideshow') {
            this.slides[structure] = content;
          } else {
            this.sections[structure] = content;
          }
        }
      }
      this.slideshowIds = Object.keys(this.slides);
      return this.collectionIds = Object.keys(this.sections);
    };

    Presentation.prototype.init = function(structure, content, subcontent) {
      var arr, linkArr, missing_structure, name, path, query, structure_data, type;
      content = content || '';
      subcontent = subcontent || '';
      if (this.type === 'json') {
        structure = structure || this.json.storyboard[0];
        structure_data = this.json.structures[structure];
        if (structure_data) {
          type = structure_data.type;
        } else {
          missing_structure = new View({
            template: 'missing_structure',
            structure_id: structure
          });
          this.elements.slideshows.innerHTML = missing_structure.markup;
          d.dispatchEvent(appError);
          throw new Error('Referenced structure in app.init does not exist: ' + structure);
        }
      } else {
        type = type || 'slideshow';
      }
      query = window.location.search;
      if (query) {
        arr = query.split('=');
        if (arr[0] === '?path') {
          path = arr[1].match(/^(\w+\.?\w*\.?\w*)/)[1];
          linkArr = path.split('.');
          name = linkArr[0];
          content = linkArr[1] || '';
          subcontent = linkArr[2] || '';
        } else if (arr[0] === '?slide') {
          this.show(arr[1]);
          return;
        }
      }
      this.goTo(structure, content, subcontent);
      if (this.isLinear) {
        Navigator.configure({
          transition: 'linear'
        });
      }
    };

    Presentation.prototype.add = function(name, content, type) {
      type = type || 'slideshow';
      if (type === 'slideshow') {
        this.slideshowIds.push(name);
        this.slides[name] = content;
      } else {
        this.collectionIds.push(name);
        this.sections[name] = content;
      }
      this.json.structures[name] = {
        name: name,
        content: content,
        type: type
      };
      this.register(name, content, type);
    };

    Presentation.prototype.addEvent = function(type, callback, ele) {
      var base, currentSlide, eventInstance, src;
      currentSlide = app.slideshow.current;
      src = ele || document;
      eventInstance = [type, callback, src];
      if ((base = this.savedEvents)[currentSlide] == null) {
        base[currentSlide] = [];
      }
      this.savedEvents[currentSlide].eventInstance;
      this.savedEvents[currentSlide].push(eventInstance);
      src.addEventListener(type, callback);
    };

    Presentation.prototype.removeEvents = function(slideName) {
      var currentSlide, event, i, len, ref;
      currentSlide = slideName || this.slideshow.current;
      if (this.savedEvents[currentSlide]) {
        ref = this.savedEvents[currentSlide];
        for (i = 0, len = ref.length; i < len; i++) {
          event = ref[i];
          event[2].removeEventListener(event[0], event[1]);
        }
      }
      delete this.savedEvents[currentSlide];
    };

    Presentation.prototype.removeElements = function(slideName) {
      var currentSlide, ele, elements, results;
      currentSlide = slideName || this.slideshow.current;
      elements = app.slide[currentSlide].element;
      if (elements) {
        results = [];
        for (ele in elements) {
          results.push(elements[ele] = null);
        }
        return results;
      }
    };

    Presentation.prototype.register = function(name, content, type) {
      type = type || 'slideshow';
      if (this.json) {
        this.manager[name] = new SlideManager(name, this.json);
      }
      if (type === 'slideshow') {
        this.slideshows[name] = new Slideshow(name, content);
      } else {
        this.collections[name] = new Collection(name, content);
      }
    };

    Presentation.prototype.unregister = function(name, type) {
      type = type || 'slideshow';
      if (type === 'slideshow') {
        delete this.slides[name];
      } else {
        delete this.sections[name];
      }
    };

    Presentation.prototype.load = function(name, skipSync) {
      var type;
      type = indexOf.call(this.slideshowIds, name) >= 0 ? 'slideshow' : 'collection';
      if (this.loaded) {
        this.unLoad();
      }
      if (type === 'slideshow') {
        this.slideshow = this.loaded = this.slideshows[name];
        this.slideshow.parent = null;
        this.collection = null;
        this.loaded.onLoad();
      } else {
        this.collection = this.loaded = this.collections[name];
        this.slideshow = null;
        this.loaded.onLoad();
        this.setCurrent(this.collection.content[0]);
        this.insertSections(this.collection.content, this.collection.ele);
      }
      this.elements.presentation.classList.add(name);
      this.insert(this.loaded);
      this.getSlides();
      this.loaded.ele.dispatchEvent(contentLoad);
      if (!skipSync) {
        this.sync();
      }
    };

    Presentation.prototype.unLoad = function() {
      var evt, type;
      type = this.loaded.constructor.name;
      evt = type === 'Slideshow' ? slideshowUnload : collectionUnload;
      this.loaded.ele.dispatchEvent(evt);
      this.loaded.ele.dispatchEvent(contentUnload);
      this.elements.presentation.classList.remove(this.loaded.id);
      this.loaded.onUnload();
      this.remove(this.loaded);
    };

    Presentation.prototype.insert = function(slideshow, container) {
      container = container || this.elements.slideshows;
      container.appendChild(slideshow.ele);
    };

    Presentation.prototype.insertSections = function(sections, container) {
      var i, len, missing_structure, slideshow, ss;
      for (i = 0, len = sections.length; i < len; i++) {
        slideshow = sections[i];
        ss = this.slideshows[slideshow];
        if (ss) {
          ss.direction = 'vertical';
          ss.parent = this.loaded;
          this.slideshows[slideshow].onLoad();
          this.insert(this.slideshows[slideshow], this.loaded.ele);
        } else {
          missing_structure = new View({
            template: 'missing_structure',
            structure_id: slideshow
          });
          this.elements.slideshows.innerHTML = missing_structure.markup;
          d.dispatchEvent(appError);
          throw new Error('Referenced section is not a slideshow: ' + slideshow);
        }
      }
    };

    Presentation.prototype.remove = function(slideshow, container) {
      container = container || this.elements.slideshows;
      container.removeChild(slideshow.ele);
    };

    Presentation.prototype.getData = function(path, callback) {
      var xhr;
      xhr = new XMLHttpRequest();
      xhr.open('GET', path, false);
      xhr.onreadystatechange = (function(_this) {
        return function() {
          if (xhr.readyState !== 4) {
            return;
          }
          if (xhr.status !== 0 && xhr.status !== 200) {
            if (xhr.status === 400) {
              console.log("Could not locate " + path);
            } else {
              console.error("app.getData " + path + " HTTP error: " + xhr.status);
            }
            return;
          }
          return callback(JSON.parse(xhr.responseText));
        };
      })(this);
      xhr.send();
    };

    Presentation.prototype.getHtml = function(name, path, callback) {
      var xhr;
      if (path == null) {
        path = this.pathToSlides;
      }
      path = path.replace(/<id>/g, name) + name + '.html';
      xhr = new XMLHttpRequest();
      xhr.open('GET', path, false);
      xhr.onreadystatechange = (function(_this) {
        return function() {
          var missing_slide;
          if (xhr.readyState !== 4) {
            return;
          }
          if (xhr.status !== 0 && xhr.status !== 200) {
            if (xhr.status === 400) {
              console.log("Could not locate " + path);
            } else {
              missing_slide = new View({
                template: 'missing_slide',
                slide_id: name
              });
              callback(missing_slide.markup);
              return d.dispatchEvent(appError);
            }
          } else {
            return callback(xhr.responseText);
          }
        };
      })(this);
      xhr.send();
    };

    Presentation.prototype.getPath = function() {
      var parent, path;
      path = '/';
      path += this.currentSlide;
      parent = this.slide[this.currentSlide].parent;
      if (parent) {
        path = '/' + parent.id + path;
        while (parent = parent.parent) {
          path = '/' + parent.id + path;
        }
      }
      return path;
    };

    Presentation.prototype.getAllSlides = function() {
      var addEmptyFunctions, arr, i, len, name, ref, slide, slideMethods;
      this.allSlides = [];
      this.slide = {};
      slideMethods = ['onEnter', 'onExit'];
      addEmptyFunctions = function(slide) {
        var i, len, method, results;
        app.slide[slide] = {};
        results = [];
        for (i = 0, len = slideMethods.length; i < len; i++) {
          method = slideMethods[i];
          results.push(app.slide[slide][method] = function() {});
        }
        return results;
      };
      ref = this.slides;
      for (name in ref) {
        arr = ref[name];
        for (i = 0, len = arr.length; i < len; i++) {
          slide = arr[i];
          if (indexOf.call(this.allSlides, slide) < 0) {
            this.allSlides.push(slide);
            addEmptyFunctions(slide);
          }
        }
      }
    };

    Presentation.prototype.getElements = function() {
      var eleId, globals, i, len;
      globals = this.config.globalElements;
      this.elements = this.elements || {};
      this.elements.presentation = d.getElementById('presentation');
      this.elements.slideshows = d.getElementById('slideshows');
      if (globals) {
        for (i = 0, len = globals.length; i < len; i++) {
          eleId = globals[i];
          this.elements[eleId] = d.getElementById(eleId);
        }
      }
    };

    Presentation.prototype.getSlides = function() {
      var i, len, slide, slides;
      this.slideElements = {};
      slides = d.querySelectorAll('.slide');
      for (i = 0, len = slides.length; i < len; i++) {
        slide = slides[i];
        this.slideElements[slide.id] = slide;
      }
    };

    Presentation.prototype.getSlideElements = function(slideName, ele) {
      var el, elements, results, slideObj, value;
      slideObj = app.slide[slideName];
      slideObj.element = {};
      elements = slideObj.elements;
      if (elements) {
        results = [];
        for (el in elements) {
          value = elements[el];
          if (typeof value === 'string') {
            results.push(slideObj.element[el] = ele.querySelector(value));
          } else {
            if (value[1] === 'all') {
              results.push(slideObj.element[el] = ele.querySelectorAll(value[0]));
            } else {
              results.push(slideObj.element[el] = ele.querySelector(value[0]));
            }
          }
        }
        return results;
      }
    };

    Presentation.prototype.goTo = function(name, content, subcontent) {
      var skipExit;
      skipExit = false;
      if (!this.loaded || name !== this.loaded.id) {
        skipExit = true;
        this.load(name, true);
      }
      if (content) {
        this.manager[name].goTo(content, subcontent);
      }
      this.sync(skipExit);
    };

    Presentation.prototype.show = function(content) {
      var arr;
      arr = [];
      if (typeof content === 'string') {
        arr[0] = content;
      } else {
        arr = content;
      }
      app.add('temp', arr);
      app.load('temp');
    };

    Presentation.prototype.setCurrent = function(name) {
      this.slideshow = this.slideshows[name];
    };

    Presentation.prototype.sync = function(loaded) {
      var collection, data, previous, previousCollection, slide;
      if (loaded == null) {
        loaded = false;
      }
      data = this.manager[this.loaded.id].resolve();
      slide = app.slideElements[data.slide];
      previous = app.slideElements[data.previousSlide];
      if (this.slideshow.embedded.length) {
        this.slideshow.removeEmbedded();
      }
      if (data.previousChapter && data.previousChapter !== data.chapter) {
        previousCollection = app.slideshows[data.previousChapter];
        previousCollection.ele.dispatchEvent(sectionExit);
      }
      if (data.previousSlide && data.previousSlide === this.currentSlide) {
        previous.dispatchEvent(slideExit);
        this.slide[data.previousSlide].onExit(previous);
        this.removeEvents(data.previousSlide);
        this.removeElements(data.previousSlide);
      }
      if (loaded || (data.chapter && data.chapter !== data.previousChapter)) {
        collection = app.slideshows[data.chapter];
        this.setCurrent(data.chapter);
        this.collection._setCurrent(data.index.h);
        collection.ele.dispatchEvent(sectionEnter);
      }
      this.slideshow._setCurrent(data.slide);
      this.slide[data.slide].ele = slide;
      this.currentSlide = data.slide;
      console.log(slide);
      console.log(data);
      console.log(app.slideElements);
      slide.dispatchEvent(slideEnter);
      this.getSlideElements(data.slide, slide);
      return this.slide[data.slide].onEnter(slide);
    };

    Presentation.prototype.template = function(str, data) {
      var p;
      for (p in data) {
        str = str.replace(new RegExp('{' + p + '}', 'g'), data[p]);
      }
      return str;
    };

    return Presentation;

  })();

  window.Slideshow = Slideshow = (function() {
    var ele, prefix, style;

    ele = document.createElement('div');

    style = ele.style;

    if ('transform' in style) {
      prefix = '';
    } else if ('WebkitTransform' in style) {
      prefix = '-webkit-';
    } else if ('MozTransform' in style) {
      prefix = '-moz-';
    } else if ('msTransform' in style) {
      prefix = '-ms-';
    } else if ('oTransform' in style) {
      prefix = '-o-';
    }

    function Slideshow(id, content1, config1) {
      this.id = id;
      this.content = content1;
      this.config = config1 != null ? config1 : {};
      this.type = 'slideshow';
      this.direction = this.config.direction || 'horizontal';
      this.currentIndex = 0;
      this.inline = {};
      this.embedded = [];
      this.markup = '';
    }

    Slideshow.prototype._createElement = function(inline) {
      var classes, section;
      classes = inline ? 'inline-slideshow' : 'slideshow';
      if (app.loaded.type === 'collection') {
        classes += ' slide';
      }
      section = document.createElement('section');
      section.setAttribute('id', this.id + 'Container');
      section.setAttribute('class', classes);
      this.ele = section;
    };

    Slideshow.prototype._createMarkup = function() {
      var append, file, i, j, len, len1, obj, prepend, ref, ref1, slide;
      prepend = '';
      append = '';
      if (app.type === 'json') {
        ref = this.content;
        for (i = 0, len = ref.length; i < len; i++) {
          slide = ref[i];
          obj = app.json.slides[slide];
          if (!app.slide[slide]) {
            app.slide[slide] = {
              onEnter: function() {},
              onExit: function() {}
            };
          }
          app.slide[slide].parent = this;
          if (obj) {
            if (obj.file) {
              file = obj.file;
              slide = file.split('.')[0];
            }
          }
          app.getHtml(slide, app.pathToSlides, (function(_this) {
            return function(str) {
              return _this.markup += prepend + str + append;
            };
          })(this));
        }
      } else {
        ref1 = this.content;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          slide = ref1[j];
          app.getHtml(slide, app.pathToSlides, (function(_this) {
            return function(str) {
              return _this.markup += prepend + str + append;
            };
          })(this));
        }
      }
    };

    Slideshow.prototype._destroyElement = function() {
      this.ele = null;
    };

    Slideshow.prototype._isValid = function(name) {
      return indexOf.call(this.content, name) >= 0;
    };

    Slideshow.prototype._reset = function() {
      this.direction = 'horizontal';
      this.current = this.content[0];
      this.currentIndex = 0;
      this.length = this.content.length;
      this.markup = '';
    };

    Slideshow.prototype._scroll = function(nr, skipExit) {
      var currentSlide, prevClass, previous, slide;
      skipExit = skipExit || false;
      slide = app.slideElements[this.content[nr]];
      previous = app.slideElements[this.current];
      if (previous === slide) {
        skipExit = true;
      }
      if (!skipExit) {
        if (this.isInline) {
          prevClass = this.currentIndex > nr ? 'future' : 'past';
          previous.classList.remove('present');
          previous.classList.add(prevClass);
        } else {
          this.removeEmbedded();
        }
        previous.dispatchEvent(slideExit);
        app.slide[this.current].onExit(previous);
        app.removeEvents(previous.id);
        app.removeElements(previous.id);
      }
      this._setCurrent(nr);
      currentSlide = app.slide[this.current];
      currentSlide.ele = slide;
      if (this.isInline) {
        slide.classList.add('present');
        slide.classList.remove('past');
        slide.classList.remove('future');
      }
      slide.dispatchEvent(slideEnter);
      app.getSlideElements(this.current, slide);
      currentSlide.onEnter(slide);
    };

    Slideshow.prototype._setCurrent = function(content) {
      var type;
      type = typeof content;
      if (type === 'string') {
        this.current = content;
        this.currentIndex = this.getIndex(content);
      } else if ('number') {
        this.current = this.content[content];
        this.currentIndex = content;
      }
    };

    Slideshow.prototype._setMeasurements = function() {
      if (this.direction === 'horizontal') {
        this.width = app.dimensions[0] * this.length;
      } else {
        this.width = app.dimensions[0];
      }
    };

    Slideshow.prototype.embed = function(slideshowId, container, scroll) {
      var i, len, scroller, slide, slides, slideshow;
      if (scroll == null) {
        scroll = true;
      }
      if (container) {
        slideshow = app.slideshows[slideshowId];
        scroller = scroll ? new InlineScroller(container, slideshow) : '';
        slideshow.onLoad(true);
        slideshow.parent = this;
        app.insert(slideshow, container);
        this.inline[slideshowId] = slideshow;
        this.inline[slideshowId].scroller = scroller;
        this.embedded.push({
          slideshow: slideshowId,
          container: container
        });
        slides = slideshow.ele.querySelectorAll('.slide');
        for (i = 0, len = slides.length; i < len; i++) {
          slide = slides[i];
          slide.classList.add('future');
          app.slideElements[slide.id] = slide;
        }
        slides[0].classList.add('present');
        slides[0].classList.remove('future');
        this.inline[slideshowId].scrollTo(0);
      } else {
        throw new Error('Missin container parameter in call to app.embed');
      }
    };

    Slideshow.prototype.removeEmbedded = function() {
      var embed, i, len, ref, slide;
      ref = this.embedded;
      for (i = 0, len = ref.length; i < len; i++) {
        embed = ref[i];
        slide = this.inline[embed.slideshow].current;
        ele = app.slideElements[slide];
        this.inline[embed.slideshow].onUnload();
        this.inline[embed.slideshow].scroller = null;
        app.removeEvents(slide);
        app.removeElements(slide);
        embed.container.innerHTML = '';
        delete this.inline[embed.slideshow];
      }
      this.embedded = [];
    };

    Slideshow.prototype.get = function(name) {
      if (name) {
        return document.getElementById(name);
      } else {
        return document.getElementById(this.current);
      }
    };

    Slideshow.prototype.getIndex = function(name) {
      if (name && this._isValid(name)) {
        return this.content.indexOf(name);
      } else {
        return this.content.indexOf(this.current);
      }
    };

    Slideshow.prototype.onLoad = function(inline) {
      this.isInline = inline;
      this.current = this.content[0];
      this.length = this.content.length;
      this._setMeasurements();
      this._createElement(inline);
      this._createMarkup();
      return this.ele.innerHTML = this.markup;
    };

    Slideshow.prototype.onUnload = function() {
      var previous;
      previous = app.slideElements[this.current];
      previous.dispatchEvent(slideExit);
      app.slide[this.current].onExit(previous);
      this._reset();
    };

    Slideshow.prototype.next = function() {
      if (this.isInline) {
        if (this.currentIndex < this.length - 1) {
          this._scroll(this.currentIndex + 1);
        }
      } else {
        app.manager[app.loaded.id].next();
        app.sync();
      }
    };

    Slideshow.prototype.previous = function() {
      if (this.isInline) {
        if (this.currentIndex > 0) {
          this._scroll(this.currentIndex - 1);
        }
      } else {
        app.manager[app.loaded.id].previous();
        app.sync();
      }
    };

    Slideshow.prototype.scrollTo = function(content, skipExit) {
      var collection, order, slide, slideshow, type;
      skipExit = skipExit || false;
      type = typeof content;
      if (this.isInline) {
        if (type === 'string') {
          order = this.getIndex(content);
          this._scroll(order, skipExit);
        } else if (type === 'number') {
          order = Math.abs(content);
          this._scroll(order, skipExit);
        }
      } else {
        if (type === 'number') {
          order = Math.abs(content);
          content = this.content[order];
        }
        if (this.type === "slideshow") {
          collection = app.loaded.id;
          slideshow = this.id;
          slide = content;
          if (slideshow === collection) {
            slideshow = slide;
            slide = null;
          }
        } else {
          collection = this.id;
          slideshow = content;
          slide = null;
        }
        app.goTo(collection, slideshow, slide);
      }
    };

    Slideshow.prototype.scrollToEnd = function() {
      app.manager[app.loaded.id].gotoLast();
      app.sync();
    };

    Slideshow.prototype.scrollToStart = function() {
      app.manager[app.loaded.id].gotoFirst();
      app.sync();
    };

    return Slideshow;

  })();

  window.Collection = Collection = (function(superClass) {
    var ele, style;

    extend(Collection, superClass);

    function Collection() {
      return Collection.__super__.constructor.apply(this, arguments);
    }

    ele = document.createElement('div');

    style = ele.style;

    Collection.prototype._resetSection = function() {
      var ss;
      ss = app.slideshow;
      return setTimeout(function() {
        return ss._setCurrent(0);
      }, 600);
    };

    Collection.prototype._scroll = function(nr, skipExit) {
      var collection, currentSlide, nextSlide, previous;
      skipExit = skipExit || false;
      collection = app.slideshows[this.content[nr]];
      previous = app.slideshows[this.current];
      nextSlide = app.slideElements[collection.content[0]];
      currentSlide = app.slideElements[previous.current];
      if (!skipExit) {
        previous.removeEmbedded();
        previous.ele.dispatchEvent(sectionExit);
        currentSlide.dispatchEvent(slideExit);
        app.slide[currentSlide.id].onExit(currentSlide);
        app.removeEvents(currentSlide.id);
        app.removeElements(currentSlide.id);
      }
      this._resetSection();
      this._setCurrent(nr);
      app.setCurrent(this.current);
      collection.ele.dispatchEvent(sectionEnter);
      nextSlide.dispatchEvent(slideEnter);
      app.getSlideElements(nextSlide.id, nextSlide);
      return app.slide[nextSlide.id].onEnter(nextSlide);
    };

    Collection.prototype.onLoad = function() {
      this.type = 'collection';
      this.current = this.content[0];
      this.length = this.content.length;
      this._setMeasurements();
      this._createElement();
      return this.ele.setAttribute('class', 'collection');
    };

    Collection.prototype.onUnload = function() {
      var collection, currentSlide, i, len, ref, results, section;
      collection = app.slideshows[this.current];
      currentSlide = app.slideElements[collection.content[0]];
      currentSlide.dispatchEvent(slideExit);
      app.slide[currentSlide.id].onExit(currentSlide);
      collection.ele.dispatchEvent(sectionExit);
      this._reset();
      ref = this.content;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        section = ref[i];
        results.push(app.slideshows[section]._reset());
      }
      return results;
    };

    Collection.prototype.get = function(name) {
      if (name) {
        return document.getElementById(name + 'Container');
      } else {
        return document.getElementById(this.current + 'Container');
      }
    };

    Collection.prototype.next = function() {
      if (app.isLinear) {
        app.manager[app.loaded.id].next();
      } else {
        app.manager[app.loaded.id].right();
      }
      app.sync();
    };

    Collection.prototype.previous = function() {
      if (app.isLinear) {
        app.manager[app.loaded.id].previous();
      } else {
        app.manager[app.loaded.id].left();
      }
      app.sync();
    };

    return Collection;

  })(Slideshow);

  d = document;

  window.Slidescroller = Slidescroller = (function() {
    function Slidescroller(id) {
      this.id = id;
      this._down = bind(this._down, this);
      this._up = bind(this._up, this);
      this._previous = bind(this._previous, this);
      this._next = bind(this._next, this);
      this.ele = app.elements.presentation;
      this.type = 'slideshow';
      this.actions = {
        left: this._next,
        right: this._previous,
        up: this._up,
        down: this._down
      };
      this._connect();
    }

    Slidescroller.prototype._connect = function() {
      d.addEventListener('contentLoad', (function(_this) {
        return function() {
          if (_this.id === app.loaded.id) {
            _this.ele = d.getElementById(_this.id);
          }
          _this.type = app.loaded.type;
          return _this._actionSetup;
        };
      })(this));
      this.enableAll();
    };

    Slidescroller.prototype._actionSetup = function() {
      if (this.type === 'slideshow') {
        this._next = this._nextSlide;
        return this._previous = this._previousSlide;
      } else {
        this._next = this._nextSection;
        this._previous = this._previousSection;
        this._up = this._nextSlide;
        return this._down = this._previousSlide;
      }
    };

    Slidescroller.prototype._next = function(event) {
      if (this.type === 'slideshow') {
        this._nextSlide(event);
      } else {
        this._nextSection(event);
      }
    };

    Slidescroller.prototype._previous = function(event) {
      if (this.type === 'slideshow') {
        this._previousSlide(event);
      } else {
        this._previousSection(event);
      }
    };

    Slidescroller.prototype._up = function(event) {
      if (this.type === 'collection') {
        this._nextSlide(event);
      }
    };

    Slidescroller.prototype._down = function(event) {
      if (this.type === 'collection') {
        this._previousSlide(event);
      }
    };

    Slidescroller.prototype._addSwipeListener = function(eventName) {
      this.ele.addEventListener(eventName, this.events[eventName]);
    };

    Slidescroller.prototype._nextSection = function(event) {
      app.collection.next();
    };

    Slidescroller.prototype._nextSlide = function(event) {
      app.slideshow.next();
    };

    Slidescroller.prototype._previousSection = function(event) {
      app.collection.previous();
    };

    Slidescroller.prototype._previousSlide = function(event) {
      app.slideshow.previous();
    };

    Slidescroller.prototype._nextInline = function(event) {
      touchy.stop(event);
      app.inline.next();
    };

    Slidescroller.prototype._previousInline = function(event) {
      touchy.stop(event);
      app.inline.previous();
    };

    Slidescroller.prototype.disable = function(dir) {
      this.ele.removeEventListener('swipe' + dir, this.actions[dir]);
    };

    Slidescroller.prototype.disableAll = function() {
      this.ele.removeEventListener('swipeleft', this._next);
      this.ele.removeEventListener('swiperight', this._previous);
      this.ele.removeEventListener('swipeup', this._up);
      this.ele.removeEventListener('swipedown', this._down);
    };

    Slidescroller.prototype.enable = function(dir) {
      this.ele.addEventListener('swipe' + dir, this.actions[dir]);
    };

    Slidescroller.prototype.enableAll = function() {
      this.ele.addEventListener('swipeleft', this._next);
      this.ele.addEventListener('swiperight', this._previous);
      this.ele.addEventListener('swipeup', this._up);
      this.ele.addEventListener('swipedown', this._down);
    };

    Slidescroller.prototype.enableInline = function() {
      app.inline.ele.addEventListener('swipeleft', this._nextInline);
      app.inline.ele.addEventListener('swiperight', this._previousInline);
    };

    Slidescroller.prototype.disableInline = function() {
      app.inline.ele.removeEventListener('swipeleft', this._nextInline);
      app.inline.ele.removeEventListener('swiperight', this._previousInline);
    };

    return Slidescroller;

  })();

  d = document;

  window.InlineScroller = InlineScroller = (function(superClass) {
    extend(InlineScroller, superClass);

    function InlineScroller(ele1, structure1) {
      this.ele = ele1;
      this.structure = structure1;
      this._previous = bind(this._previous, this);
      this._next = bind(this._next, this);
      this.actions = {
        left: this._next,
        right: this._previous
      };
      this._connect();
    }

    InlineScroller.prototype._connect = function() {
      this.enableAll();
    };

    InlineScroller.prototype._next = function(event) {
      touchy.stop(event);
      this.structure.next();
    };

    InlineScroller.prototype._previous = function(event) {
      touchy.stop(event);
      this.structure.previous();
    };

    InlineScroller.prototype.disable = function(dir) {
      this.ele.removeEventListener('swipe' + dir, this.actions[dir]);
    };

    InlineScroller.prototype.disableAll = function() {
      this.ele.removeEventListener('swipeleft', this._next);
      this.ele.removeEventListener('swiperight', this._previous);
    };

    InlineScroller.prototype.enable = function(dir) {
      this.ele.addEventListener('swipe' + dir, this.actions[dir]);
    };

    InlineScroller.prototype.enableAll = function() {
      this.ele.addEventListener('swipeleft', this._next);
      this.ele.addEventListener('swiperight', this._previous);
    };

    return InlineScroller;

  })(Slidescroller);

  window.View = View = (function() {
    function View(config1) {
      var name, path, template;
      this.config = config1 != null ? config1 : {};
      this.markup = '';
      template = this.config.template || null;
      path = this.config.path || '_framework/templates/';
      name = this.config.name || null;
      if (template) {
        return View.template[template](this.config);
      } else if (name) {
        return this.compile(name, path);
      }
    }

    View.prototype.compile = function(name, path) {
      var blueprint, output, template_data;
      blueprint = '';
      app.getHtml(name, path, function(data) {
        return blueprint = data;
      });
      output = app.template(blueprint, this.config.data);
      template_data = {
        markup: output
      };
      return template_data;
    };

    return View;

  })();

  View.template = {
    missing_slide: function(config) {
      var blueprint, output, template_data;
      blueprint = '';
      app.getHtml('error_missing_slide', '_framework/templates/', function(data) {
        return blueprint = data;
      });
      output = app.template(blueprint, {
        slide_id: config.slide_id
      });
      template_data = {
        name: 'Missing slide: ' + config.slide_id,
        markup: output
      };
      return template_data;
    },
    missing_structure: function(config) {
      var blueprint, output, template_data;
      blueprint = '';
      app.getHtml('error_missing_structure', '_framework/templates/', function(data) {
        return blueprint = data;
      });
      output = app.template(blueprint, {
        structure_id: config.structure_id
      });
      template_data = {
        name: 'Missing structure: ' + config.structure_id,
        markup: output
      };
      return template_data;
    }
  };

  window.AutoMenu = AutoMenu = (function() {
    function AutoMenu(config) {
      this._setCurrent = bind(this._setCurrent, this);
      this.config = config || {};
      this.offset = this.config.offset || 0;
      this.offsetLinks = this.config.offsetLinks || null;
      this.append = this.config.append || null;
      this.prepend = this.config.prepend || null;
      this.linksConfig = this.config.links || {};
      this.linkIds = null;
      this.attachTo = this.config.attachTo || [];
      this.content = this.config.content || null;
      this.ele = document.getElementById('mainmenu');
      this.orientation = this.config.orientation || 'horizontal';
      this.initialized = false;
      this.singleContent = false;
      if (this.attachTo) {
        this._init();
      }
    }

    AutoMenu.prototype._init = function() {
      document.addEventListener('contentLoad', (function(_this) {
        return function() {
          var ref;
          if (ref = app.loaded.id, indexOf.call(_this.attachTo, ref) >= 0) {
            _this.singleContent = true;
            return _this._load();
          } else if (_this.attachTo === 'storyboard' || _this.content) {
            _this.structurePath = app.json.structures;
            return _this._load();
          }
        };
      })(this));
      return document.addEventListener('contentUnload', (function(_this) {
        return function() {
          if (_this.attachTo.indexOf(app.loaded.id > -1)) {
            _this._remove();
            if (_this.contentType === 'slideshow') {
              return document.removeEventListener('slideEnter', self._setCurrent);
            } else {
              return document.removeEventListener('sectionEnter', self._setCurrent);
            }
          }
        };
      })(this));
    };

    AutoMenu.prototype._load = function() {
      this.ele.addEventListener('swipeleft', touchy.stop);
      this.ele.addEventListener('swiperight', touchy.stop);
      this.ele.addEventListener('swipeup', touchy.stop);
      this.ele.addEventListener('swipedown', touchy.stop);
      if (this.singleContent) {
        this.contentType = app.loaded.type;
        this.linkIds = app[this.contentType].content;
        if (this.contentType === 'collection') {
          document.addEventListener('sectionEnter', this._setCurrent);
          this.structurePath = app.json.structures;
        } else {
          document.addEventListener('slideEnter', this._setCurrent);
          this.structurePath = app.json.slides;
        }
      } else {
        this.linkIds = this.content || app.json.storyboard;
        document.addEventListener('contentLoad', this._setCurrent);
      }
      if (!this.initialized) {
        this._build();
      }
      this._insert();
      this._connect();
      return this._setCurrent();
    };

    AutoMenu.prototype._build = function() {
      var aClass, aLink, classname, i, j, k, len, len1, len2, link, linkConfig, markup, name, pClass, pLink, ref, ref1, ref2, skip;
      markup = '';
      if (this.prepend) {
        ref = this.prepend;
        for (i = 0, len = ref.length; i < len; i++) {
          pLink = ref[i];
          pClass = pLink.classname || '';
          markup += "<li data-link='" + pLink.goTo + "' class='" + pClass + "'>" + pLink.title + "</li>";
        }
      }
      ref1 = this.linkIds;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        link = ref1[j];
        linkConfig = this.linksConfig[link];
        name = this.structurePath[link].name;
        if (this.singleContent) {
          link = app.loaded.id + "." + link;
        }
        classname = '';
        if (linkConfig) {
          skip = linkConfig.skip || false;
          name = linkConfig.title || name;
          classname = linkConfig.classname || '';
        }
        if (!skip) {
          markup += "<li data-link='" + link + "' class='" + classname + "'>" + name + "</li>";
        } else {
          skip = false;
        }
      }
      if (this.append) {
        ref2 = this.append;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          aLink = ref2[k];
          aClass = aLink.classname || '';
          markup += "<li data-link='" + aLink.goTo + "' class='" + aClass + "'>" + aLink.title + "</li>";
        }
      }
      return this.markup = markup;
    };

    AutoMenu.prototype._insert = function() {
      var classes, count, list, offset, scrollLimit;
      list = document.createElement('ul');
      classes = 'menu';
      if (this.orientation === 'vertical') {
        classes += ' vert-menu';
      }
      scrollLimit = 0;
      list.id = app.loaded.id + 'Menu';
      list.setAttribute('class', classes);
      list.innerHTML = this.markup;
      this.ele.appendChild(list);
      this.list = list;
      this._getWidth();
      if (this.offsetLinks) {
        this.config.offset = 0;
        count = -1;
        while ((count += 1) <= this.offsetLinks - 1) {
          this.config.offset += parseInt(this.linkWidths[count]);
        }
        this.config.offset = this.config.offset * -1;
        offset = this.config.offset;
      } else {
        offset = this.offset;
      }
      if (this.orientation === 'horizontal') {
        scrollLimit = app.dimensions[0] - this.menuWidth;
        if (scrollLimit < 0) {
          this.scroller = new Draggy(list.id, {
            restrictY: true,
            limitsX: [scrollLimit, 0],
            onChange: (function(_this) {
              return function(x, y) {
                return _this.offset = x;
              };
            })(this)
          });
          if (this.orientation === 'horizontal') {
            return this.scroller.moveTo(offset, 0);
          }
        } else {
          return this.scroller = null;
        }
      }
    };

    AutoMenu.prototype._remove = function() {
      this.ele.removeEventListener('tap', this._navigate);
      return this.ele.innerHTML = '';
    };

    AutoMenu.prototype._getWidth = function() {
      var i, len, link, links, results, width;
      links = this.ele.querySelectorAll('li');
      this.menuWidth = 0;
      this.linkWidths = [];
      results = [];
      for (i = 0, len = links.length; i < len; i++) {
        link = links[i];
        width = link.getBoundingClientRect().width;
        this.menuWidth += width;
        results.push(this.linkWidths.push(width));
      }
      return results;
    };

    AutoMenu.prototype._navigate = function(event) {
      var attr, content, ele, linkArr, name, prev, subcontent;
      ele = event.target;
      if (ele.nodeType === 3) {
        ele = ele.parentNode;
      }
      prev = this.querySelector('.selected');
      attr = ele.getAttribute('data-link');
      if (attr) {
        if (prev) {
          util.removeClass(prev, 'selected');
        }
        linkArr = attr.split('.');
        name = linkArr[0];
        content = linkArr[1] || '';
        subcontent = linkArr[2] || '';
        util.addClass(ele, 'selected');
        if (name === 'app') {
          return eval(attr);
        } else {
          return app.goTo(name, content, subcontent);
        }
      }
    };

    AutoMenu.prototype._connect = function() {
      return this.ele.addEventListener('tap', this._navigate);
    };

    AutoMenu.prototype._setCurrent = function() {
      var absOffset, appWidth, content, defaultOffset, link, menuPos, pos, prev, query, realPos, rightPos, toMove, wd;
      prev = this.ele.querySelector('.selected');
      content = this.singleContent ? app.loaded.id + "." + app.loaded.current : app.loaded.id;
      query = "[data-link='" + content + "']";
      link = this.ele.querySelector(query);
      if (prev) {
        util.removeClass(prev, 'selected');
      }
      if (link) {
        util.addClass(link, 'selected');
        if (this.scroller) {
          realPos = util.getPosition(link)[0];
          menuPos = util.getPosition(this.ele);
          pos = realPos + this.offset;
          wd = link.getBoundingClientRect().width;
          rightPos = pos + wd;
          toMove = 0;
          defaultOffset = this.config.offset || 0;
          absOffset = Math.abs(defaultOffset);
          appWidth = this.ele.getBoundingClientRect().width;
          if (rightPos >= appWidth) {
            toMove = (rightPos - appWidth) - this.offset - menuPos[0];
            this.list.style.webkitTransitionDuration = '0.5s';
            this.list.style.webkitTransform = 'translate3d(-' + toMove + 'px, 0, 0)';
            this.offset = -toMove;
          } else if (pos < 0) {
            toMove = pos - this.offset - menuPos[0];
            this.list.style.webkitTransitionDuration = '0.5s';
            this.list.style.webkitTransform = 'translate3d(-' + toMove + 'px, 0, 0)';
            this.offset = -toMove;
          } else if (rightPos > absOffset && (realPos + wd) < appWidth) {
            toMove = defaultOffset;
            this.list.style.webkitTransitionDuration = '0.5s';
            this.list.style.webkitTransform = 'translate3d(' + toMove + 'px, 0, 0)';
            this.offset = toMove;
          }
          return setTimeout((function(_this) {
            return function() {
              return _this.scroller.moveTo(_this.offset, 0);
            };
          })(this), 500);
        }
      }
    };

    return AutoMenu;

  })();

  window.debug = function() {
    document.addEventListener('presentationInit', function() {
      console.log("**** Presentation initialized");
      console.log("Registered slideshows:  " + app.slideshowIds);
      console.log("Registered collections: " + app.collectionIds);
      return window["debugger"].init();
    });
    document.addEventListener('slideshowLoad', function() {
      return console.log("**** Slideshow loaded: " + app.slideshow.id);
    });
    document.addEventListener('slideshowUnload', function() {
      return console.log("**** Slideshow unloaded: " + app.slideshow.id);
    });
    document.addEventListener('collectionLoad', function() {
      return console.log("**** Collection loaded: " + app.collection.id);
    });
    document.addEventListener('collectionUnload', function() {
      return console.log("**** Collection unloaded: " + app.collection.id);
    });
    document.addEventListener('inlineSlideshowLoad', function() {
      return console.log("**** Inline slideshow loaded: " + app.inline.id);
    });
    document.addEventListener('inlineSlideshowUnload', function() {
      return console.log("**** Inline slideshow unloaded: " + app.inline.id);
    });
    document.addEventListener('contentLoad', function(event) {
      return console.log("**** New content loaded: " + event.target.id);
    });
    document.addEventListener('contentUnload', function(event) {
      return console.log("**** Content unloaded: " + event.target.id);
    });
    document.addEventListener('slideEnter', function(event) {
      return console.log("---> Slide entered: " + event.target.id);
    });
    document.addEventListener('slideExit', function(event) {
      return console.log("<--- Slide exited: " + event.target.id);
    });
    document.addEventListener('sectionEnter', function() {
      return console.log(">>>> Section entered: " + app.slideshow.id);
    });
    document.addEventListener('sectionExit', function() {
      return console.log("<<<< Section exited: " + app.slideshow.id);
    });
    document.addEventListener('inlineSlideEnter', function() {
      return console.log("---> Inline slide entered: " + app.inline.current);
    });
    return document.addEventListener('inlineSlideExit', function() {
      return console.log("<--- Inline slide exited: " + app.inline.current);
    });
  };

  window["debugger"] = {
    ele: null,
    logs: null,
    isVisible: false,
    markup: '',
    init: function() {
      this.createWindow();
      this.addListeners();
      window.doc = this.doc;
      return window.log = this.log;
    },
    createBox: function() {
      var box;
      box = new View({
        name: 'debug_console'
      });
      return console.log(box);
    },
    createWindow: function() {
      var dragger, header, leftCol, logHeader, rightCol, stateBar;
      this.ele = document.createElement('section');
      header = document.createElement('header');
      stateBar = document.createElement('div');
      this.stateStructure = document.createElement('span');
      this.stateSlide = document.createElement('span');
      leftCol = document.createElement('div');
      rightCol = document.createElement('div');
      logHeader = document.createElement('h4');
      this.logs = document.createElement('div');
      this.ele.id = 'debug';
      header.innerText = 'Debug Console';
      stateBar.className = 'state-bar';
      leftCol.className = 'd-col';
      rightCol.className = 'd-col last-col';
      logHeader.innerText = 'Log output';
      stateBar.appendChild(this.stateStructure);
      stateBar.appendChild(this.stateSlide);
      this.ele.appendChild(header);
      this.ele.appendChild(stateBar);
      document.body.appendChild(this.ele);
      return dragger = new Draggy(this.ele, {});
    },
    addListeners: function() {
      document.addEventListener('longTouch', (function(_this) {
        return function() {
          if (_this.isVisible) {
            util.removeClass(_this.ele, 'showing');
            return _this.isVisible = false;
          } else {
            util.addClass(_this.ele, 'showing');
            return _this.isVisible = true;
          }
        };
      })(this));
      return document.addEventListener('slideEnter', (function(_this) {
        return function() {
          _this.stateStructure.innerText = app.loaded.current;
          return _this.stateSlide.innerText = app.slideshow.current;
        };
      })(this));
    },
    log: function(msg) {
      var logEle;
      logEle = document.createElement('p');
      logEle.innerText = msg;
      return this.logs.appendChild(logEle);
    },
    clearLog: function() {
      return this.logs.innerHTML = '';
    },
    doc: function(name) {
      name = '?' + name || '';
      return window.location.href = '../docs/index.html' + name;
    }
  };

}).call(this);

/*!
 * reveal.js
 * http://lab.hakim.se/reveal-js
 * MIT licensed
 *
 * Copyright (C) 2016 Hakim El Hattab, http://hakim.se
 */
 // Stripped down version of Reveal to handle update of classes on slides
(function( root, factory ) {
  if( typeof define === 'function' && define.amd ) {
    // AMD. Register as an anonymous module.
    define( function() {
      root.Navigator = factory();
      return root.Navigator;
    } );
  } else if( typeof exports === 'object' ) {
    // Node. Does not work with strict CommonJS.
    module.exports = factory();
  } else {
    // Browser globals.
    root.Navigator = factory();
  }
}( this, function() {

  'use strict';

  var Navigator;

  var SLIDES_SELECTOR = '.slideshows .slide',
    HORIZONTAL_SLIDES_SELECTOR = '.slideshows>section>.slide',
    VERTICAL_SLIDES_SELECTOR = '.slideshows>section>.slide.present>.slide',
    HOME_SLIDE_SELECTOR = '.slideshows>section>.slide:first-of-type',

    // Configuration defaults, can be overridden at initialization time
    config = {

      // The "normal" size of the presentation, aspect ratio will be preserved
      // when the presentation is scaled to fit different resolutions
      width: '100%',
      height: '100%',

      // Factor of the display size that should remain empty around the content
      margin: 0,

      // Bounds for smallest/largest possible scale to apply to content
      minScale: 0.2,
      maxScale: 1.5,

      // Push each slide change to the browser history
      history: false,

      // Enable keyboard shortcuts for navigation
      keyboard: true,

      // Optional function that blocks keyboard events when retuning false
      keyboardCondition: null,

      // Enable the slide overview mode
      overview: true,

      // Vertical centering of slides
      center: false,

      // Enables touch navigation on devices with touch input
      touch: true,

      // Loop the presentation
      loop: false,

      // Change the presentation direction to be RTL
      rtl: false,

      // Hides the address bar on mobile devices
      hideAddressBar: true,

      // Dispatches all reveal.js events to the parent window through postMessage
      postMessageEvents: false,

      // Focuses body when page changes visiblity to ensure keyboard shortcuts work
      focusBodyOnPageVisibilityChange: true,

      // Transition style
      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Transition speed
      transitionSpeed: 'default', // default/fast/slow

      // Number of slides away from the current that are visible
      viewDistance: 3

    },

    // Flags if reveal.js is loaded (has dispatched the 'ready' event)
    loaded = false,

    // Flags if the overview mode is currently active
    overview = false,

    // The horizontal and vertical index of the currently active slide
    indexh,
    indexv,

    // The previous and current slide HTML elements
    previousSlide,
    currentSlide,

    previousBackground,

    // Slides may hold a data-state attribute which we pick up and apply
    // as a class to the body. This list contains the combined state of
    // all current slides.
    state = [],

    // The current scale of the presentation (see width/height config)
    scale = 1,

    // CSS transform that is currently applied to the slides container,
    // split into two groups
    slidesTransform = { layout: '', overview: '' },

    // Cached references to DOM elements
    dom = {},

    // Features supported by the browser, see #checkCapabilities()
    features = {},

    // Client is a mobile device, see #checkCapabilities()
    isMobileDevice;

  /**
   * Starts up the presentation if the client is capable.
   */
  function initialize( options ) {

    checkCapabilities();

    if( !features.transforms2d && !features.transforms3d ) {
      document.body.setAttribute( 'class', 'no-transforms' );

      // Since JS won't be running any further, we load all lazy
      // loading elements upfront
      var images = toArray( document.getElementsByTagName( 'img' ) ),
        iframes = toArray( document.getElementsByTagName( 'iframe' ) );

      var lazyLoadable = images.concat( iframes );

      for( var i = 0, len = lazyLoadable.length; i < len; i++ ) {
        var element = lazyLoadable[i];
        if( element.getAttribute( 'data-src' ) ) {
          element.setAttribute( 'src', element.getAttribute( 'data-src' ) );
          element.removeAttribute( 'data-src' );
        }
      }

      // If the browser doesn't support core features we won't be
      // using JavaScript to control the presentation
      return;
    }

    // Cache references to key DOM elements
    dom.wrapper = document.querySelector( '#presentation' );
    dom.slideshows = document.querySelector( '#presentation .slideshows' );

    // Force a layout when the whole page, incl fonts, has loaded
    window.addEventListener( 'load', layout, false );

    var query = Navigator.getQueryHash();

    // Do not accept new dependencies via query config to avoid
    // the potential of malicious script injection
    if( typeof query['dependencies'] !== 'undefined' ) delete query['dependencies'];

    // Copy options over to our config object
    extend( config, options );
    extend( config, query );

    // Hide the address bar in mobile browsers
    hideAddressBar();

    // Loads the dependencies and continues to #start() once done
    load();

  }

  /**
   * Inspect the client to see what it's capable of, this
   * should only happens once per runtime.
   */
  function checkCapabilities() {

    features.transforms3d = 'WebkitPerspective' in document.body.style ||
                'MozPerspective' in document.body.style ||
                'msPerspective' in document.body.style ||
                'OPerspective' in document.body.style ||
                'perspective' in document.body.style;

    features.transforms2d = 'WebkitTransform' in document.body.style ||
                'MozTransform' in document.body.style ||
                'msTransform' in document.body.style ||
                'OTransform' in document.body.style ||
                'transform' in document.body.style;

    features.requestAnimationFrameMethod = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
    features.requestAnimationFrame = typeof features.requestAnimationFrameMethod === 'function';

    features.canvas = !!document.createElement( 'canvas' ).getContext;

    features.touch = !!( 'ontouchstart' in window );

    // Transitions in the overview are disabled in desktop and
    // mobile Safari due to lag
    features.overviewTransitions = !/Version\/[\d\.]+.*Safari/.test( navigator.userAgent );

    isMobileDevice = /(iphone|ipod|ipad|android)/gi.test( navigator.userAgent );

  }

    /**
     * Loads the dependencies of reveal.js. Dependencies are
     * defined via the configuration option 'dependencies'
     * and will be loaded prior to starting/binding reveal.js.
     * Some dependencies may have an 'async' flag, if so they
     * will load after reveal.js has been started up.
     */
  function load() {

    start();

  }

  /**
   * Starts up reveal.js by binding input events and navigating
   * to the current URL deeplink if there is one.
   */
  function start() {

    // Make sure we've got all the DOM elements we need
    setupDOM();

    // Resets all vertical slides so that only the first is visible
    resetVerticalSlides();

    // Updates the presentation to match the current configuration values
    configure();

    // Notify listeners that the presentation is ready but use a 1ms
    // timeout to ensure it's not fired synchronously after #initialize()
    setTimeout( function() {
      // Enable transitions now that we're loaded
      dom.slideshows.classList.remove( 'no-transition' );

      loaded = true;

      dispatchEvent( 'ready', {
        'indexh': indexh,
        'indexv': indexv,
        'currentSlide': currentSlide
      } );
    }, 1 );

  }

  /**
   * Finds and stores references to DOM elements which are
   * required by the presentation. If a required element is
   * not found, it is created.
   */
  function setupDOM() {

    // Prevent transitions while we're loading
    dom.slideshows.classList.add( 'no-transition' );

    // Overlay graphic which is displayed during the paused mode
    createSingletonNode( dom.wrapper, 'div', 'pause-overlay', null );

    dom.wrapper.setAttribute( 'role', 'application' );
  }

  /**
   * Creates an HTML element and returns a reference to it.
   * If the element already exists the existing instance will
   * be returned.
   */
  function createSingletonNode( container, tagname, classname, innerHTML ) {

    // Find all nodes matching the description
    var nodes = container.querySelectorAll( '.' + classname );

    // Check all matches to find one which is a direct child of
    // the specified container
    for( var i = 0; i < nodes.length; i++ ) {
      var testNode = nodes[i];
      if( testNode.parentNode === container ) {
        return testNode;
      }
    }

    // If no node was found, create it now
    var node = document.createElement( tagname );
    node.classList.add( classname );
    if( typeof innerHTML === 'string' ) {
      node.innerHTML = innerHTML;
    }
    container.appendChild( node );

    return node;

  }

  /**
   * Applies the configuration settings from the config
   * object. May be called multiple times.
   */
  function configure( options ) {

    var numberOfSlides = dom.wrapper.querySelectorAll( SLIDES_SELECTOR ).length;

    dom.wrapper.classList.remove( config.transition );

    // New config options may be passed when this method
    // is invoked through the API after initialization
    if( typeof options === 'object' ) extend( config, options );

    // Force linear transition based on browser capabilities
    if( features.transforms3d === false ) config.transition = 'linear';

    dom.wrapper.classList.add( config.transition );

    dom.wrapper.setAttribute( 'data-transition-speed', config.transitionSpeed );

    if( config.rtl ) {
      dom.wrapper.classList.add( 'rtl' );
    }
    else {
      dom.wrapper.classList.remove( 'rtl' );
    }

    if( config.center ) {
      dom.wrapper.classList.add( 'center' );
    }
    else {
      dom.wrapper.classList.remove( 'center' );
    }

    // Exit the paused mode if it was configured off
    if( config.pause === false ) {
      resume();
    }

    sync();

  }

  /**
   * Extend object a with the properties of object b.
   * If there's a conflict, object b takes precedence.
   */
  function extend( a, b ) {

    for( var i in b ) {
      a[ i ] = b[ i ];
    }

  }

  /**
   * Converts the target object to an array.
   */
  function toArray( o ) {

    return Array.prototype.slice.call( o );

  }

  /**
   * Utility for deserializing a value.
   */
  function deserialize( value ) {

    if( typeof value === 'string' ) {
      if( value === 'null' ) return null;
      else if( value === 'true' ) return true;
      else if( value === 'false' ) return false;
      else if( value.match( /^\d+$/ ) ) return parseFloat( value );
    }

    return value;

  }

  /**
   * Measures the distance in pixels between point a
   * and point b.
   *
   * @param {Object} a point with x/y properties
   * @param {Object} b point with x/y properties
   */
  function distanceBetween( a, b ) {

    var dx = a.x - b.x,
      dy = a.y - b.y;

    return Math.sqrt( dx*dx + dy*dy );

  }

  /**
   * Applies a CSS transform to the target element.
   */
  function transformElement( element, transform ) {

    element.style.WebkitTransform = transform;
    element.style.MozTransform = transform;
    element.style.msTransform = transform;
    element.style.transform = transform;

  }

  /**
   * Applies CSS transforms to the slides container. The container
   * is transformed from two separate sources: layout and the overview
   * mode.
   */
  function transformSlides( transforms ) {

    // Pick up new transforms from arguments
    if( typeof transforms.layout === 'string' ) slidesTransform.layout = transforms.layout;
    if( typeof transforms.overview === 'string' ) slidesTransform.overview = transforms.overview;

    // Apply the transforms to the slides container
    if( slidesTransform.layout ) {
      transformElement( dom.slideshows, slidesTransform.layout + ' ' + slidesTransform.overview );
    }
    else {
      transformElement( dom.slideshows, slidesTransform.overview );
    }

  }

  /**
   * Retrieves the height of the given element by looking
   * at the position and height of its immediate children.
   */
  function getAbsoluteHeight( element ) {

    var height = 0;

    if( element ) {
      var absoluteChildren = 0;

      toArray( element.childNodes ).forEach( function( child ) {

        if( typeof child.offsetTop === 'number' && child.style ) {
          // Count # of abs children
          if( window.getComputedStyle( child ).position === 'absolute' ) {
            absoluteChildren += 1;
          }

          height = Math.max( height, child.offsetTop + child.offsetHeight );
        }

      } );

      // If there are no absolute children, use offsetHeight
      if( absoluteChildren === 0 ) {
        height = element.offsetHeight;
      }

    }

    return height;

  }

  /**
   * Returns the remaining height within the parent of the
   * target element.
   *
   * remaining height = [ configured parent height ] - [ current parent height ]
   */
  function getRemainingHeight( element, height ) {

    height = height || 0;

    if( element ) {
      var newHeight, oldHeight = element.style.height;

      // Change the .stretch element height to 0 in order find the height of all
      // the other elements
      element.style.height = '0px';
      newHeight = height - element.parentNode.offsetHeight;

      // Restore the old height, just in case
      element.style.height = oldHeight + 'px';

      return newHeight;
    }

    return height;

  }

  /**
   * Hides the address bar if we're on a mobile device.
   */
  function hideAddressBar() {

    if( config.hideAddressBar && isMobileDevice ) {
      // Events that should trigger the address bar to hide
      window.addEventListener( 'load', removeAddressBar, false );
      window.addEventListener( 'orientationchange', removeAddressBar, false );
    }

  }

  /**
   * Causes the address bar to hide on mobile devices,
   * more vertical space ftw.
   */
  function removeAddressBar() {

    setTimeout( function() {
      window.scrollTo( 0, 1 );
    }, 10 );

  }

  /**
   * Dispatches an event of the specified type from the
   * reveal DOM element.
   */
  function dispatchEvent( type, args ) {

    var event = document.createEvent( 'HTMLEvents', 1, 2 );
    event.initEvent( type, true, true );
    extend( event, args );
    dom.wrapper.dispatchEvent( event );

  }

  /**
   * Closes any currently open overlay.
   */
  function closeOverlay() {

    if( dom.overlay ) {
      dom.overlay.parentNode.removeChild( dom.overlay );
      dom.overlay = null;
    }

  }

  /**
   * Applies JavaScript-controlled layout rules to the
   * presentation.
   */
  function layout() {

    if( dom.wrapper ) {

      var size = getComputedSlideSize();

      var slidePadding = 20; // TODO Dig this out of DOM

      // Layout the contents of the slides
      layoutSlideContents( config.width, config.height, slidePadding );

      dom.slideshows.style.width = size.width + 'px';
      dom.slideshows.style.height = size.height + 'px';

      // Determine scale of content to fit within available space
      scale = Math.min( size.presentationWidth / size.width, size.presentationHeight / size.height );

      // Respect max/min scale settings
      scale = Math.max( scale, config.minScale );
      scale = Math.min( scale, config.maxScale );

      // Don't apply any scaling styles if scale is 1
      if( scale === 1 ) {
        dom.slideshows.style.zoom = '';
        dom.slideshows.style.left = '';
        dom.slideshows.style.top = '';
        dom.slideshows.style.bottom = '';
        dom.slideshows.style.right = '';
        transformSlides( { layout: '' } );
      }
      else {
        // Use zoom to scale up in desktop Chrome so that content
        // remains crisp. We don't use zoom to scale down since that
        // can lead to shifts in text layout/line breaks.
        if( scale > 1 && !isMobileDevice && /chrome/i.test( navigator.userAgent ) && typeof dom.slideshows.style.zoom !== 'undefined' ) {
          dom.slideshows.style.zoom = scale;
          dom.slideshows.style.left = '';
          dom.slideshows.style.top = '';
          dom.slideshows.style.bottom = '';
          dom.slideshows.style.right = '';
          transformSlides( { layout: '' } );
        }
        // Apply scale transform as a fallback
        else {
          dom.slideshows.style.zoom = '';
          dom.slideshows.style.left = '50%';
          dom.slideshows.style.top = '50%';
          dom.slideshows.style.bottom = 'auto';
          dom.slideshows.style.right = 'auto';
          transformSlides( { layout: 'translate(-50%, -50%) scale('+ scale +')' } );
        }
      }

      // Select all slides, vertical and horizontal
      var slides = toArray( dom.wrapper.querySelectorAll( SLIDES_SELECTOR ) );

      for( var i = 0, len = slides.length; i < len; i++ ) {
        var slide = slides[ i ];

        // Don't bother updating invisible slides
        if( slide.style.display === 'none' ) {
          continue;
        }

        if( config.center || slide.classList.contains( 'center' ) ) {
          // Vertical stacks are not centred since their section
          // children will be
          if( slide.classList.contains( 'stack' ) ) {
            slide.style.top = 0;
          }
          else {
            slide.style.top = Math.max( ( ( size.height - getAbsoluteHeight( slide ) ) / 2 ) - slidePadding, 0 ) + 'px';
          }
        }
        else {
          slide.style.top = '';
        }

      }

    }

  }

  /**
   * Applies layout logic to the contents of all slides in
   * the presentation.
   */
  function layoutSlideContents( width, height, padding ) {

    // Handle sizing of elements with the 'stretch' class
    toArray( dom.slideshows.querySelectorAll( '.slide > .stretch' ) ).forEach( function( element ) {

      // Determine how much vertical space we can use
      var remainingHeight = getRemainingHeight( element, height );

      // Consider the aspect ratio of media elements
      if( /(img|video)/gi.test( element.nodeName ) ) {
        var nw = element.naturalWidth || element.videoWidth,
          nh = element.naturalHeight || element.videoHeight;

        var es = Math.min( width / nw, remainingHeight / nh );

        element.style.width = ( nw * es ) + 'px';
        element.style.height = ( nh * es ) + 'px';

      }
      else {
        element.style.width = width + 'px';
        element.style.height = remainingHeight + 'px';
      }

    } );

  }

  /**
   * Calculates the computed pixel size of our slides. These
   * values are based on the width and height configuration
   * options.
   */
  function getComputedSlideSize( presentationWidth, presentationHeight ) {

    var size = {
      // Slide size
      width: config.width,
      height: config.height,

      // Presentation size
      presentationWidth: presentationWidth || dom.wrapper.offsetWidth,
      presentationHeight: presentationHeight || dom.wrapper.offsetHeight
    };

    // Reduce available space by margin
    size.presentationWidth -= ( size.presentationWidth * config.margin );
    size.presentationHeight -= ( size.presentationHeight * config.margin );

    // Slide width may be a percentage of available width
    if( typeof size.width === 'string' && /%$/.test( size.width ) ) {
      size.width = parseInt( size.width, 10 ) / 100 * size.presentationWidth;
    }

    // Slide height may be a percentage of available height
    if( typeof size.height === 'string' && /%$/.test( size.height ) ) {
      size.height = parseInt( size.height, 10 ) / 100 * size.presentationHeight;
    }

    return size;

  }

  /**
   * Stores the vertical index of a stack so that the same
   * vertical slide can be selected when navigating to and
   * from the stack.
   *
   * @param {HTMLElement} stack The vertical stack element
   * @param {int} v Index to memorize
   */
  function setPreviousVerticalIndex( stack, v ) {

    if( typeof stack === 'object' && typeof stack.setAttribute === 'function' ) {
      stack.setAttribute( 'data-previous-indexv', v || 0 );
    }

  }

  /**
   * Retrieves the vertical index which was stored using
   * #setPreviousVerticalIndex() or 0 if no previous index
   * exists.
   *
   * @param {HTMLElement} stack The vertical stack element
   */
  function getPreviousVerticalIndex( stack ) {

    if( typeof stack === 'object' && typeof stack.setAttribute === 'function' && stack.classList.contains( 'stack' ) ) {
      // Prefer manually defined start-indexv
      var attributeName = stack.hasAttribute( 'data-start-indexv' ) ? 'data-start-indexv' : 'data-previous-indexv';

      return parseInt( stack.getAttribute( attributeName ) || 0, 10 );
    }

    return 0;

  }

  /**
   * Checks if the current or specified slide is vertical
   * (nested within another slide).
   *
   * @param {HTMLElement} slide [optional] The slide to check
   * orientation of
   */
  function isVerticalSlide( slide ) {

    // Prefer slide argument, otherwise use current slide
    slide = slide ? slide : currentSlide;

    return slide && slide.parentNode && slide.parentNode.classList.contains( 'slide' );

  }

  /**
   * Handling the fullscreen functionality via the fullscreen API
   *
   * @see http://fullscreen.spec.whatwg.org/
   * @see https://developer.mozilla.org/en-US/docs/DOM/Using_fullscreen_mode
   */
  function enterFullscreen() {

    var element = document.body;

    // Check which implementation is available
    var requestMethod = element.requestFullScreen ||
              element.webkitRequestFullscreen ||
              element.webkitRequestFullScreen ||
              element.mozRequestFullScreen ||
              element.msRequestFullscreen;

    if( requestMethod ) {
      requestMethod.apply( element );
    }

  }

  /**
   * Steps from the current point in the presentation to the
   * slide which matches the specified horizontal and vertical
   * indices.
   *
   * @param {int} h Horizontal index of the target slide
   * @param {int} v Vertical index of the target slide
   */
  function slide( h, v ) {

    // Remember where we were at before
    previousSlide = currentSlide;

    // Query all horizontal slides in the deck
    var horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR );

    // If no vertical index is specified and the upcoming slide is a
    // stack, resume at its previous vertical index
    if( v === undefined ) {
      v = getPreviousVerticalIndex( horizontalSlides[ h ] );
    }

    // If we were on a vertical stack, remember what vertical index
    // it was on so we can resume at the same position when returning
    if( previousSlide && previousSlide.parentNode && previousSlide.parentNode.classList.contains( 'stack' ) ) {
      setPreviousVerticalIndex( previousSlide.parentNode, indexv );
    }

    // Remember the state before this slide
    var stateBefore = state.concat();

    // Reset the state array
    state.length = 0;

    var indexhBefore = indexh || 0,
      indexvBefore = indexv || 0;

    // Activate and transition to the new slide
    indexh = updateSlides( HORIZONTAL_SLIDES_SELECTOR, h === undefined ? indexh : h );
    indexv = updateSlides( VERTICAL_SLIDES_SELECTOR, v === undefined ? indexv : v );

    // Update the visibility of slides now that the indices have changed
    updateSlidesVisibility();

    layout();

    // Apply the new state
    stateLoop: for( var i = 0, len = state.length; i < len; i++ ) {
      // Check if this state existed on the previous slide. If it
      // did, we will avoid adding it repeatedly
      for( var j = 0; j < stateBefore.length; j++ ) {
        if( stateBefore[j] === state[i] ) {
          stateBefore.splice( j, 1 );
          continue stateLoop;
        }
      }

      document.documentElement.classList.add( state[i] );

      // Dispatch custom event matching the state's name
      dispatchEvent( state[i] );
    }

    // Clean up the remains of the previous state
    while( stateBefore.length ) {
      document.documentElement.classList.remove( stateBefore.pop() );
    }

    // Find the current horizontal slide and any possible vertical slides
    // within it
    var currentHorizontalSlide = horizontalSlides[ indexh ],
      currentVerticalSlides = currentHorizontalSlide.querySelectorAll( '.slide' );

    // Store references to the previous and current slides
    currentSlide = currentVerticalSlides[ indexv ] || currentHorizontalSlide;

    // Dispatch an event if the slide changed
    var slideChanged = ( indexh !== indexhBefore || indexv !== indexvBefore );
    if( slideChanged ) {
      dispatchEvent( 'slidechanged', {
        'indexh': indexh,
        'indexv': indexv,
        'previousSlide': previousSlide,
        'currentSlide': currentSlide
      } );
    }
    else {
      // Ensure that the previous slide is never the same as the current
      previousSlide = null;
    }

    // Solves an edge case where the previous slide maintains the
    // 'present' class when navigating between adjacent vertical
    // stacks
    if( previousSlide ) {
      previousSlide.classList.remove( 'present' );
      previousSlide.setAttribute( 'aria-hidden', 'true' );

      // Reset all slides upon navigate to home
      // Issue: #285
      if ( dom.wrapper.querySelector( HOME_SLIDE_SELECTOR ).classList.contains( 'present' ) ) {
        // Launch async task
        setTimeout( function () {
          var slides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.stack') ), i;
          for( i in slides ) {
            if( slides[i] ) {
              // Reset stack
              setPreviousVerticalIndex( slides[i], 0 );
            }
          }
        }, 0 );
      }
    }

  }

  /**
   * Syncs the presentation with the current DOM. Useful
   * when new slides or control elements are added or when
   * the configuration has changed.
   */
  function sync() {

    // Force a layout to make sure the current config is accounted for
    layout();

    updateSlidesVisibility();

  }

  /**
   * Resets all vertical slides so that only the first
   * is visible.
   */
  function resetVerticalSlides() {

    var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );
    horizontalSlides.forEach( function( horizontalSlide ) {

      var verticalSlides = toArray( horizontalSlide.querySelectorAll( '.slide' ) );
      verticalSlides.forEach( function( verticalSlide, y ) {

        if( y > 0 ) {
          verticalSlide.classList.remove( 'present' );
          verticalSlide.classList.remove( 'past' );
          verticalSlide.classList.add( 'future' );
          verticalSlide.setAttribute( 'aria-hidden', 'true' );
        }

      } );

    } );

  }

  /**
   * Updates one dimension of slides by showing the slide
   * with the specified index.
   *
   * @param {String} selector A CSS selector that will fetch
   * the group of slides we are working with
   * @param {Number} index The index of the slide that should be
   * shown
   *
   * @return {Number} The index of the slide that is now shown,
   * might differ from the passed in index if it was out of
   * bounds.
   */
  function updateSlides( selector, index ) {

    // Select all slides and convert the NodeList result to
    // an array
    var slides = toArray( dom.wrapper.querySelectorAll( selector ) ),
      slidesLength = slides.length;


    if( slidesLength ) {

      // Should the index loop?
      if( config.loop ) {
        index %= slidesLength;

        if( index < 0 ) {
          index = slidesLength + index;
        }
      }

      // Enforce max and minimum index bounds
      index = Math.max( Math.min( index, slidesLength - 1 ), 0 );

      for( var i = 0; i < slidesLength; i++ ) {
        var element = slides[i];

        var reverse = config.rtl && !isVerticalSlide( element );

        element.classList.remove( 'past' );
        element.classList.remove( 'present' );
        element.classList.remove( 'future' );

        // http://www.w3.org/html/wg/drafts/html/master/editing.html#the-hidden-attribute
        element.setAttribute( 'hidden', '' );
        element.setAttribute( 'aria-hidden', 'true' );

        // If this element contains vertical slides
        if( element.querySelector( '.slide' ) ) {
          element.classList.add( 'stack' );
        }

        if( i < index ) {
          // Any element previous to index is given the 'past' class
          element.classList.add( reverse ? 'future' : 'past' );
        }
        else if( i > index ) {
          // Any element subsequent to index is given the 'future' class
          element.classList.add( reverse ? 'past' : 'future' );
        }
      }

      // Mark the current slide as present
      slides[index].classList.add( 'present' );
      slides[index].removeAttribute( 'hidden' );
      slides[index].removeAttribute( 'aria-hidden' );

      // If this slide has a state associated with it, add it
      // onto the current state of the deck
      var slideState = slides[index].getAttribute( 'data-state' );
      if( slideState ) {
        state = state.concat( slideState.split( ' ' ) );
      }

    }
    else {
      // Since there are no slides we can't be anywhere beyond the
      // zeroth index
      index = 0;
    }

    return index;

  }

  /**
   * Optimization method; hide all slides that are far away
   * from the present slide.
   */
  function updateSlidesVisibility() {

    // Select all slides and convert the NodeList result to
    // an array
    var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) ),
      horizontalSlidesLength = horizontalSlides.length,
      distanceX,
      distanceY;

    if( horizontalSlidesLength && typeof indexh !== 'undefined' ) {

      // The number of steps away from the present slide that will
      // be visible
      var viewDistance = config.viewDistance;

      // Limit view distance on weaker devices
      if( isMobileDevice ) {
        viewDistance = 2;
      }

      for( var x = 0; x < horizontalSlidesLength; x++ ) {
        var horizontalSlide = horizontalSlides[x];

        var verticalSlides = toArray( horizontalSlide.querySelectorAll( '.slide' ) ),
          verticalSlidesLength = verticalSlides.length;

        // Determine how far away this slide is from the present
        distanceX = Math.abs( ( indexh || 0 ) - x ) || 0;

        // If the presentation is looped, distance should measure
        // 1 between the first and last slides
        if( config.loop ) {
          distanceX = Math.abs( ( ( indexh || 0 ) - x ) % ( horizontalSlidesLength - viewDistance ) ) || 0;
        }

        // Show the horizontal slide if it's within the view distance
        if( distanceX < viewDistance ) {
          showSlide( horizontalSlide );
        }
        else {
          hideSlide( horizontalSlide );
        }

        if( verticalSlidesLength ) {

          var oy = getPreviousVerticalIndex( horizontalSlide );

          for( var y = 0; y < verticalSlidesLength; y++ ) {
            var verticalSlide = verticalSlides[y];

            distanceY = x === ( indexh || 0 ) ? Math.abs( ( indexv || 0 ) - y ) : Math.abs( y - oy );

            if( distanceX + distanceY < viewDistance ) {
              showSlide( verticalSlide );
            }
            else {
              hideSlide( verticalSlide );
            }
          }

        }
      }

    }

  }

  /**
   * Called when the given slide is within the configured view
   * distance. Shows the slide element and loads any content
   * that is set to load lazily (data-src).
   */
  function showSlide( slide ) {

    // Show the slide element
    slide.style.display = 'block';

    // Media elements with data-src attributes
    toArray( slide.querySelectorAll( 'img[data-src], video[data-src], audio[data-src]' ) ).forEach( function( element ) {
      element.setAttribute( 'src', element.getAttribute( 'data-src' ) );
      element.removeAttribute( 'data-src' );
    } );

    // Media elements with <source> children
    toArray( slide.querySelectorAll( 'video, audio' ) ).forEach( function( media ) {
      var sources = 0;

      toArray( media.querySelectorAll( 'source[data-src]' ) ).forEach( function( source ) {
        source.setAttribute( 'src', source.getAttribute( 'data-src' ) );
        source.removeAttribute( 'data-src' );
        sources += 1;
      } );

      // If we rewrote sources for this video/audio element, we need
      // to manually tell it to load from its new origin
      if( sources > 0 ) {
        media.load();
      }
    } );

  }

  /**
   * Called when the given slide is moved outside of the
   * configured view distance.
   */
  function hideSlide( slide ) {

    // Hide the slide element
    slide.style.display = 'none';

  }

  /**
   * Determine what available routes there are for navigation.
   *
   * @return {Object} containing four booleans: left/right/up/down
   */
  function availableRoutes() {

    var horizontalSlides = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),
      verticalSlides = dom.wrapper.querySelectorAll( VERTICAL_SLIDES_SELECTOR );

    var routes = {
      left: indexh > 0 || config.loop,
      right: indexh < horizontalSlides.length - 1 || config.loop,
      up: indexv > 0,
      down: indexv < verticalSlides.length - 1
    };

    // reverse horizontal controls for rtl
    if( config.rtl ) {
      var left = routes.left;
      routes.left = routes.right;
      routes.right = left;
    }

    return routes;

  }

  /**
   * Returns the number of past slides. This can be used as a global
   * flattened index for slides.
   */
  function getSlidePastCount() {

    var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );

    // The number of past slides
    var pastCount = 0;

    // Step through all slides and count the past ones
    mainLoop: for( var i = 0; i < horizontalSlides.length; i++ ) {

      var horizontalSlide = horizontalSlides[i];
      var verticalSlides = toArray( horizontalSlide.querySelectorAll( '.slide' ) );

      for( var j = 0; j < verticalSlides.length; j++ ) {

        // Stop as soon as we arrive at the present
        if( verticalSlides[j].classList.contains( 'present' ) ) {
          break mainLoop;
        }

        pastCount++;

      }

      // Stop as soon as we arrive at the present
      if( horizontalSlide.classList.contains( 'present' ) ) {
        break;
      }

      // Don't count the wrapping section for vertical slides
      if( horizontalSlide.classList.contains( 'stack' ) === false ) {
        pastCount++;
      }

    }

    return pastCount;

  }

  /**
   * Retrieves the h/v location of the current, or specified,
   * slide.
   *
   * @param {HTMLElement} slide If specified, the returned
   * index will be for this slide rather than the currently
   * active one
   *
   * @return {Object} { h: <int>, v: <int>, f: <int> }
   */
  function getIndices( slide ) {

    // By default, return the current indices
    var h = indexh,
      v = indexv,
      f;

    // If a slide is specified, return the indices of that slide
    if( slide ) {
      var isVertical = isVerticalSlide( slide );
      var slideh = isVertical ? slide.parentNode : slide;

      // Select all horizontal slides
      var horizontalSlides = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );

      // Now that we know which the horizontal slide is, get its index
      h = Math.max( horizontalSlides.indexOf( slideh ), 0 );

      // Assume we're not vertical
      v = undefined;

      // If this is a vertical slide, grab the vertical index
      if( isVertical ) {
        v = Math.max( toArray( slide.parentNode.querySelectorAll( '.slide' ) ).indexOf( slide ), 0 );
      }
    }

    return { h: h, v: v, f: f };

  }

  /**
   * Retrieves the total number of slides in this presentation.
   */
  function getTotalSlides() {

    return dom.wrapper.querySelectorAll( SLIDES_SELECTOR + ':not(.stack)' ).length;

  }

  /**
   * Returns the slide element matching the specified index.
   */
  function getSlide( x, y ) {

    var horizontalSlide = dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR )[ x ];
    var verticalSlides = horizontalSlide && horizontalSlide.querySelectorAll( '.slide' );

    if( verticalSlides && verticalSlides.length && typeof y === 'number' ) {
      return verticalSlides ? verticalSlides[ y ] : undefined;
    }

    return horizontalSlide;

  }

  function navigateLeft() {

    // Reverse for RTL
    if( config.rtl ) {
      if( availableRoutes().left ) {
        slide( indexh + 1 );
      }
    }
    // Normal navigation
    else if( availableRoutes().left ) {
      slide( indexh - 1 );
    }

  }

  function navigateRight() {

    // Reverse for RTL
    if( config.rtl ) {
      if( availableRoutes().right ) {
        slide( indexh - 1 );
      }
    }
    // Normal navigation
    else if( availableRoutes().right ) {
      slide( indexh + 1 );
    }

  }

  function navigateUp() {

    if( availableRoutes().up ) {
      slide( indexh, indexv - 1 );
    }

  }

  function navigateDown() {

    if( availableRoutes().down ) {
      slide( indexh, indexv + 1 );
    }

  }

  /**
   * Navigates backwards, prioritized in the following order:
   * 1) Previous vertical slide
   * 2) Previous horizontal slide
   */
  function navigatePrev() {

    if( availableRoutes().up ) {
      navigateUp();
    }
    else {
      // Fetch the previous horizontal slide, if there is one
      var previousSlide;

      if( config.rtl ) {
        previousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.future' ) ).pop();
      }
      else {
        previousSlide = toArray( dom.wrapper.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.past' ) ).pop();
      }

      if( previousSlide ) {
        var v = ( previousSlide.querySelectorAll( '.slide' ).length - 1 ) || undefined;
        var h = indexh - 1;
        slide( h, v );
      }
    }

  }

  /**
   * The reverse of #navigatePrev().
   */
  function navigateNext() {

    if( availableRoutes().down ) {
      navigateDown();
    }
    else if( config.rtl ) {
      navigateLeft();
    }
    else {
      navigateRight();
    }

  }

  /**
   * Checks if the target element prevents the triggering of
   * swipe navigation.
   */
  function isSwipePrevented( target ) {

    while( target && typeof target.hasAttribute === 'function' ) {
      if( target.hasAttribute( 'data-prevent-swipe' ) ) return true;
      target = target.parentNode;
    }

    return false;

  }


  /**
   * Handler for the window level 'resize' event.
   */
  function onWindowResize( event ) {

    layout();

  }

  /**
   * Handle for the window level 'visibilitychange' event.
   */
  function onPageVisibilityChange( event ) {

    var isHidden =  document.webkitHidden ||
            document.msHidden ||
            document.hidden;

    // If, after clicking a link or similar and we're coming back,
    // focus the document.body to ensure we can use keyboard shortcuts
    if( isHidden === false && document.activeElement !== document.body ) {
      // Not all elements support .blur() - SVGs among them.
      if( typeof document.activeElement.blur === 'function' ) {
        document.activeElement.blur();
      }
      document.body.focus();
    }

  }


  // --------------------------------------------------------------------//
  // ------------------------------- API --------------------------------//
  // --------------------------------------------------------------------//


  Navigator = {
    initialize: initialize,
    configure: configure,
    sync: sync,

    // Navigation methods
    slide: slide,
    left: navigateLeft,
    right: navigateRight,
    up: navigateUp,
    down: navigateDown,
    prev: navigatePrev,
    next: navigateNext,

    // Deprecated aliases
    navigateTo: slide,
    navigateLeft: navigateLeft,
    navigateRight: navigateRight,
    navigateUp: navigateUp,
    navigateDown: navigateDown,
    navigatePrev: navigatePrev,
    navigateNext: navigateNext,

    // Forces an update in slide layout
    layout: layout,

    // Returns an object with the available routes as booleans (left/right/top/bottom)
    availableRoutes: availableRoutes,

    // Returns the indices of the current, or specified, slide
    getIndices: getIndices,

    getTotalSlides: getTotalSlides,

    // Returns the slide element at the specified index
    getSlide: getSlide,

    // Returns the previous slide element, may be null
    getPreviousSlide: function() {
      return previousSlide;
    },

    // Returns the current slide element
    getCurrentSlide: function() {
      return currentSlide;
    },

    // Returns the current scale of the presentation content
    getScale: function() {
      return scale;
    },

    // Returns the current configuration object
    getConfig: function() {
      return config;
    },

    // Helper method, retrieves query string as a key/value hash
    getQueryHash: function() {
      var query = {};

      location.search.replace( /[A-Z0-9]+?=([\w\.%-]*)/gi, function(a) {
        query[ a.split( '=' ).shift() ] = a.split( '=' ).pop();
      } );

      // Basic deserialization
      for( var i in query ) {
        var value = query[ i ];

        query[ i ] = deserialize( unescape( value ) );
      }

      return query;
    },

    // Returns true if we're currently on the first slide
    isFirstSlide: function() {
      return ( indexh === 0 && indexv === 0 );
    },

    // Returns true if we're currently on the last slide
    isLastSlide: function() {
      if( currentSlide ) {
        // Does this slide has next a sibling?
        if( currentSlide.nextElementSibling ) return false;

        // If it's vertical, does its parent have a next sibling?
        if( isVerticalSlide( currentSlide ) && currentSlide.parentNode.nextElementSibling ) return false;

        return true;
      }

      return false;
    },

    // Checks if reveal.js has been loaded and is ready for use
    isReady: function() {
      return loaded;
    }

  };

  return Navigator;

}));

Navigator.navigate = function() {
  var hIndex = app.loaded.getIndex();
  var vIndex = app.slideshow.getIndex();
  if (app.loaded.type === 'collection') {
    Navigator.slide(hIndex, vIndex);
  }
  else {
    Navigator.slide(hIndex, 0);
  }
}

document.addEventListener('contentLoad', function() {
  Navigator.initialize();
  Navigator.navigate();
});

document.addEventListener('slideEnter', function() {
  Navigator.navigate();
});


/**
 * === CLASS SlideList ===
 *
 * A class that will keep track and manipulate a 
 * (nested) list of slide ids.
 *
 */

function SlideList(list) {
  var list = list || [];
  this.init(list);
}

SlideList.prototype.init = function (list) {
  this.list = list;
  this.current = {h:0, v:0};
}

// Total number of items in list (length of flattended array)
SlideList.prototype.size = function() {
  var flat = [];
  flat = flat.concat.apply(flat, this.list);
  return flat.length;
}

/**
  * Retrieves the list item at provided index. Falls back to
  * providing current item if no index provided
  *
  * @param {Number} h If specified, the returned
  * list item will be for this horizontal index
  * rather than the current one
  *
  * @param {Number} v If specified, the returned
  * list item will be for this vertical index
  * rather than the current one
  *
  * @return {String} list item
  */
SlideList.prototype.get = function (h, v) {
  var itemType;
  // Use current if no index provided
  if (h === undefined) {
    h = this.current.h;
    v = this.current.v;
  }
  v = v || 0;
  itemType = this.getType(h);
  if (itemType) {
    if (itemType === 'list') {
      return this.list[h][v];
    }
    // If v is not 0 or undefined
    else if (!v) {
      return this.list[h];
    }
  }
  return undefined;
}

SlideList.prototype.getIndex = function (item) {
  var h = this.list.indexOf(item);
  var index;
  if (item) {
    if (h > -1) {
      return {h: h, v: 0}
    }
    // Need to look in nested lists
    else {
      // TODO: improve loop so that we stop when we find it
      this.list.forEach(function(list, i) {
        if (typeof list !== 'string') {
          h = list.indexOf(item);
          if (h > -1) {
            index = {h: i, v: h}
          }
        }
      });
      return index;
    }
  }
  else {
    return this.current;
  }
  return undefined;
}

// An item in the list can be either "item" or "list"
SlideList.prototype.getType = function(h) {
  // In range?
  if (h > -1 && h < this.list.length) {
    // TODO: improve type check
    if (typeof this.list[h] === 'string') {
      return "item";
    }
    else {
      return "list";
    }
  }
  return undefined;
}

// Check if there is an item at the provided indices
SlideList.prototype.inRange = function (h) {
  if (h > -1 && h < this.list.length) {
    return true;
  }
  return false;
}

// Compare two indices to see if they are equal
// TODO: make into class method
SlideList.prototype.isEqual = function (i1, i2) {
  if (JSON.stringify(i1) === JSON.stringify(i2)) {
    return true;
  }
  return false;
}

SlideList.prototype._set = function(index) {
  var previous = this.current;
  // Setting by name
  // if (typeof index === 'string') {
  //   index = getIndex(index);
  // }
  // if (index > -1 && index < list.length) {
    this.current = index;
  // }
  //
}


SlideList.prototype.getList = function () {
  return this.list;
 }

SlideList.prototype.setList = function(arr) {
  var currentId = this.get();
  var newIndex;
  this.list = arr;
  newIndex = this.getIndex(currentId);
  if (!this.inRange(this.current.h) || !newIndex) {
    this._set({h:0, v:0});
  }
  else {
    this._set(newIndex);
  }
};

// TODO: properly handle non-existing strings
SlideList.prototype.goTo = function(index) {
  var index = index || {h:0, v:0};
  // Setting by name
  if (typeof index === 'string') {
    index = this.getIndex(index);
  }
index.h = index.h || 0;
  index.v = index.v || 0;
  if (this.get(index.h, index.v)) {
    this._set(index);
  }
}

// Should only move horizontally
SlideList.prototype.left = function() {
   var index = {h: this.current.h - 1, v: 0};
   if (this.get(index.h)) {
     this._set(index);
   }
 };

// Should only move horizontally
SlideList.prototype.right = function () {
  var index = {h: this.current.h + 1, v: 0};
  if (this.get(index.h)) {
    this._set(index);
  }
};

// Should only move vertically
SlideList.prototype.down = function() {
 var index = {h: this.current.h, v: this.current.v + 1};
 if (this.get(index.h, index.v)) {
   this._set(index);
 }
};

// Should only move vertically
SlideList.prototype.up = function() {
 var index = {h: this.current.h, v: this.current.v - 1};
 if (this.get(index.h, index.v)) {
   this._set(index);
 }
};

SlideList.prototype.getUp = function() {
  var upIndex = {h: this.current.h, v: this.current.v - 1};
  var itemAbove = this.get(upIndex.h, upIndex.v);
  if (itemAbove) {
    return upIndex;
  }
  return undefined;
}
SlideList.prototype.getDown = function() {
  var downIndex = {h: this.current.h, v: this.current.v + 1};
  var itemBelow = this.get(downIndex.h, downIndex.v);
  if (itemBelow) {
    return downIndex;
  }
  return undefined;
}
SlideList.prototype.getRight = function() {
  var rightIndex = {h: this.current.h + 1, v: 0};
  var itemRight = this.get(rightIndex.h, 0);
  if (itemRight) {
    return rightIndex;
  }
  return undefined;
}
SlideList.prototype.getLeft = function() {
  var leftIndex = {h: this.current.h - 1, v: 0};
  var itemLeft = this.get(leftIndex.h, 0);
  if (itemLeft) {
    return leftIndex;
  }
  return undefined;
}

// Return the ids of any available neighbor
// @return [leftId, upId, rightId, downId]
SlideList.prototype.getNeighbors = function(index) {
  var indices = [];
  // var index = index || this.getIndex();
  // ids[0] = this.get(index.h - 1, 0); // left
  // ids[1] = this.get(index.h, index.v - 1); // up
  // ids[2] = this.get(index.h + 1, 0); // right
  // ids[3] = this.get(index.h, index.v + 1); // down
  indices[0] = this.getLeft();
  indices[1] = this.getUp();
  indices[2] = this.getRight();
  indices[3] = this.getDown();
  return indices;
}

// Return the next item available (down or right)
SlideList.prototype.getNext = function() {
   // See if there is an item below to go to
   // else go to the next item to the right if available
   var downIndex = {h: this.current.h, v: this.current.v + 1};
   var rightIndex = {h: this.current.h + 1, v: 0};
   var itemBelow = this.get(downIndex.h, downIndex.v);
   var itemRight;
   if (itemBelow) {
     return downIndex;
   }
   else {
     itemRight = this.get(rightIndex.h, 0);
     if (itemRight) return rightIndex;
   }
   return undefined;
}

// Should move vertically if possible
SlideList.prototype.next = function() {
  var nextItem = this.getNext();
  if (nextItem) this._set(nextItem);
};

// Should move vertically if possible
SlideList.prototype.previous = function() {
  // See if there is an item above
  var upIndex = {h: this.current.h, v: this.current.v - 1};
  var leftIndex = {h: this.current.h - 1, v: 0};
  var itemAbove = this.get(upIndex.h, upIndex.v);
  var itemLeft, leftType;

  if (itemAbove) {
    this._set(upIndex);
  }
  else {
   // See if previous item is a list or a string
   leftType = this.getType(leftIndex.h);
   if (leftType === 'item') {
     this._set(leftIndex);
   }
   else if (leftType === 'list') {
     // Find last item in list
     leftIndex.v = this.list[leftIndex.h].length - 1;
     this._set(leftIndex);
   }
  }
};

SlideList.prototype.gotoFirst = function() {
  this._set({h:0, v:0});
};

// TODO: make this actually go to last if nested array
SlideList.prototype.gotoLast = function() {
  this._set({h:this.list.length - 1, v:0});
};

SlideList.prototype.append = function(item) {
  // var previous = list.slice();
  this.list.push(item);
};

SlideList.prototype.prepend = function(item) {
  // var previous = list.slice();
  this.list.unshift(item);
  this._set({h: this.current.h + 1, v: 0});
};

SlideList.prototype.insert = function(item, index) {
  // var previous = get(index.h, index.v);
  var prevType = this.getType(index.h);

  // if (prevType === 'item') {
    this.list.splice(index.h, 0, item);
    if (index.h <= this.current.h) this._set({h: this.current.h + 1, v: 0});
  // }
  // else if (prevType === 'list' && typeof item === 'string') {
  //   this.list[index.h].splice(index.v, 0, item);
  //   if (index.h === this.current.h && index.v <= this.current.v) {
  //     this._set({h: index.h, v: this.current.v + 1});
  //   }
  // }
};

SlideList.prototype.insertNested = function(item, index) {
  var prevType = this.getType(index.h);
  if (prevType === 'list' && typeof item === 'string') {
    this.list[index.h].splice(index.v, 0, item);
    if (index.h === this.current.h && index.v <= this.current.v) {
      this._set({h: index.h, v: this.current.v + 1});
    }
  }
};

SlideList.prototype.replace = function(index, item) {
  var previous;
  var prevType;

  if (typeof index === 'string') {
   previous = index;
   index = this.getIndex(index);
  }
  else {
   previous = this.get(index.h, index.v);
  }

  prevType = this.getType(index.h);

  if (prevType === 'list' && typeof item === 'string') {
   // Replace single item in nested list
   this.list[index.h].splice(index.v, 1, item);
  }
  else if (prevType === 'item' || prevType === 'list') {
   // Replace entire nested list or string item
   this.list.splice(index.h, 1, item);
  }
};

SlideList.prototype.remove = function(index) {
  var previous;
  var prevType;

  if (typeof index === 'string') {
   previous = index;
   index = this.getIndex(index);
  }
  else {
   previous = this.get(index.h, index.v);
  }

  prevType = this.getType(index.h);

  if (prevType === 'list' && index.v !== undefined) {
   // Replace single item in nested list
   this.list[index.h].splice(index.v, 1);
  }
  else if (prevType === 'item' || prevType === 'list') {
   // Replace entire nested list or string item
   this.list.splice(index.h, 1);
  }
};

SlideList.prototype.move = function(from, to) {
  var item, itemAtIndex, itemType, locationType;

  if (typeof from === 'string') {
    item = from;
    from = this.getIndex(from);
  }
  else {
    item = this.get(from.h, from.v);
  }

  if (typeof to === 'string') {
    itemAtIndex = to;
    to = this.getIndex(to);
  }
  else {
    itemAtIndex = this.get(to.h, to.v);
  }

  itemType = this.getType(from.h);
  locationType = this.getType(to.h);

  if (itemType === 'item' && locationType === 'item') {
    // Move single item to single item location
    if (from.h < to.h) to.h = to.h - 1; // Make sure location index is correct after removing item
    this.list.splice(from.h, 1);
    this.list.splice(to.h, 0, item);
  }
  else if (itemType === 'item' && locationType === 'list') {
   if (to.v !== undefined) {
     // Move single item into nested list
     if (from.h < to.h) to.h = to.h - 1; // Make sure location index is correct after removing item
     this.list.splice(from.h, 1);
     this.list[to.h].splice(to.v, 0, item);
   }
   else {
     // Move single item to nested list location
     if (from.h < to.h) to.h = to.h - 1; // Make sure location index is correct after removing item
     this.list.splice(from.h, 1);
     this.list.splice(to.h, 0, item);
   }
  }
  else if (itemType === 'list' && locationType === 'item') {
    if (from.v !== undefined) {
     // Move item in nested list to single item location
     // TODO: check if item is the only one in nested list, if so nested list should be removed
     this.list[from.h].splice(from.v, 1);
     this.list.splice(to.h, 0, item);
    }
    else {
     // Move nested list to single item location
     if (from.h < to.h) to.h = to.h - 1; // Make sure location index is correct after removing item
     this.list.splice(from.h, 1);
     this.list.splice(to.h, 0, item);
    }
  }
  else if (itemType === 'list' && locationType === 'list') {
    if (to.v !== undefined && from.v !== undefined) {
     // Move item in nested list into a nested list
     // TODO: check if item is the only one in nested list, if so nested list should be removed
     if (from.h === to.h && from.v < to.v) to.v = to.v - 1;
     this.list[from.h].splice(from.v, 1);
     this.list[to.h].splice(to.v, 0, item);
    }
    else if (to.v === undefined && from.v === undefined) {
     // Move nested list to nested list location
     if (from.h < to.h) to.h = to.h - 1; // Make sure location index is correct after removing item
     this.list.splice(from.h, 1);
     this.list.splice(to.h, 0, item);
    }
    else if (to.v === undefined && from.v !== undefined) {
     // Move item in nested list to nested list location
     // TODO: check if item is the only one in nested list, if so nested list should be removed
     this.list[from.h].splice(from.v, 1);
     this.list.splice(to.h, 0, item);
    }
  }
};
/**
 * === CLASS SlideManager ===
 *
 * A class that will manage a structure of slides
 * 
 * REQUIRES SlideList Class
 *
 */

function SlideManager(id, model) {
    if (!id || !model) {
        console.log('SlideManager parameter is missing');
    }
    else {
        this.initialize(id, model);
    }
}

// Register a SlideManager instance
SlideManager.prototype.initialize = function (id, model) {
    this.id = id;
    this.model = model;
    this.previousSlide = "";
    this.previousChapter = "";
    this.previousIndex = {};
    this.content = []; // Will hold original content array
    this.slideshow = new SlideList(this.resolveChapters());
}

// Resolve SlideList from model
SlideManager.prototype.resolveChapters = function() {
    var sb = this.model.structures[this.id];
    // if (!sb) {
    //     sb = [this.model.slides[this.id]];
    // }
    this.content = sb.content || [];
    var slides = this.content.slice(0);
    if (slides.length) {
        this.chapterMap = {};
        slides.forEach(function(slide, i) {
            if (this.model.structures[slide]) {
                if (!this.model.slides[slide]) { // If same id is used then slideId is used
                    slides.splice(i, 1, this.model.structures[slide].content.slice(0));
                    this.chapterMap[i] = slide; // So that we can find structure in model
                }
            }
        }.bind(this));
    }
    return slides;
}

SlideManager.prototype.resolve = function(index) {
    index = index || this.slideshow.getIndex();
    var info = {};
    info.id = this.id;
    if (this.chapterMap) info.chapter = this.chapterMap[index.h] || null;
    info.slide = this.slideshow.get(index.h, index.v);
    info.index = index;
    info.previousSlide = this.previousSlide;
    info.previousChapter = this.previousChapter;
    info.previousIndex = this.previousIndex;
    return info;
}

// Get the array index of a chapter in a slideshow
SlideManager.prototype.getChapterPosition = function(chapter) {
    if (!chapter) return -1;
    var index;
    return this.content.indexOf(chapter);
}

SlideManager.prototype.navigate = function(method, params) {
    var prevIndex = this.slideshow.getIndex();
    this.previousSlide = this.slideshow.get();
    this.previousIndex = this.slideshow.getIndex();
    this.previousChapter = this.chapterMap[prevIndex.h] || "";
    this.slideshow[method].apply(this.slideshow, params);
}

SlideManager.prototype.goTo = function(chapter, slide) {
    var chapterIndex = this.getChapterPosition(chapter);
    var searchIndex = {v: 0};
    if (chapterIndex > -1) {
        searchIndex.h = chapterIndex;
        if (slide) {
            // find slide index
            if (this.slideshow.list[searchIndex.h].indexOf) {
                searchIndex.v = this.slideshow.list[searchIndex.h].indexOf(slide);
                if (searchIndex.v < 0) searchIndex.v = 0;
            }
        }
        this.navigate("goTo", [searchIndex]);
    }
    // ignore as chapter wasn't found (can't find slide then)
    else if (slide) {
        return;
    }
    // treat the chapter param as the slide
    else {
        this.navigate("goTo", [chapter]);
    }
}

SlideManager.prototype.next = function() {
    this.navigate("next");
}

SlideManager.prototype.previous = function() {
    this.navigate("previous");
}

SlideManager.prototype.left = function() {
    this.navigate("left");
}

SlideManager.prototype.right = function() {
    this.navigate("right");
}

SlideManager.prototype.up = function() {
    this.navigate("up");
}

SlideManager.prototype.down = function() {
    this.navigate("down");
}